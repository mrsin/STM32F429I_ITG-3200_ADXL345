ARM GAS  /tmp/ccQbVy9H.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"main.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	aTxBuffer
  20              		.section	.bss.aTxBuffer,"aw",%nobits
  21              		.align	2
  24              	aTxBuffer:
  25 0000 00000000 		.space	4
  26              		.comm	aRxBuffer,3,4
  27              		.global	i2c
  28              		.section	.bss.i2c,"aw",%nobits
  31              	i2c:
  32 0000 00       		.space	1
  33              		.global	POWER_CTL
  34              		.section	.data.POWER_CTL,"aw",%progbits
  37              	POWER_CTL:
  38 0000 2D       		.byte	45
  39              		.global	DATA_FORMAT
  40              		.section	.data.DATA_FORMAT,"aw",%progbits
  43              	DATA_FORMAT:
  44 0000 31       		.byte	49
  45              		.global	DATAX0
  46              		.section	.data.DATAX0,"aw",%progbits
  49              	DATAX0:
  50 0000 32       		.byte	50
  51              		.global	DATAX1
  52              		.section	.data.DATAX1,"aw",%progbits
  55              	DATAX1:
  56 0000 33       		.byte	51
  57              		.global	DATAY0
  58              		.section	.data.DATAY0,"aw",%progbits
  61              	DATAY0:
  62 0000 34       		.byte	52
  63              		.global	DATAY1
  64              		.section	.data.DATAY1,"aw",%progbits
  67              	DATAY1:
  68 0000 35       		.byte	53
  69              		.global	DATAZ0
  70              		.section	.data.DATAZ0,"aw",%progbits
  73              	DATAZ0:
  74 0000 36       		.byte	54
  75              		.global	DATAZ1
ARM GAS  /tmp/ccQbVy9H.s 			page 2


  76              		.section	.data.DATAZ1,"aw",%progbits
  79              	DATAZ1:
  80 0000 37       		.byte	55
  81              		.section	.rodata
  82              		.align	2
  83              	.LC0:
  84 0000 52656164 		.ascii	"Read error\000"
  84      20657272 
  84      6F7200
  85 000b 00       		.align	2
  86              	.LC1:
  87 000c 783A2025 		.ascii	"x: %d\000"
  87      6400
  88 0012 0000     		.align	2
  89              	.LC2:
  90 0014 20793A20 		.ascii	" y: %d\000"
  90      256400
  91 001b 00       		.align	2
  92              	.LC3:
  93 001c 207A3A20 		.ascii	" z: %d\000"
  93      256400
  94 0023 00       		.align	2
  95              	.LC4:
  96 0024 206C6F6F 		.ascii	" loop per second: %d\012\000"
  96      70207065 
  96      72207365 
  96      636F6E64 
  96      3A202564 
  97 003a 0000     		.section	.text.main,"ax",%progbits
  98              		.align	2
  99              		.global	main
 100              		.thumb
 101              		.thumb_func
 103              	main:
 104              	.LFB125:
 105              		.file 1 "Src/main.c"
   1:Src/main.c    **** /**
   2:Src/main.c    ****   ******************************************************************************
   3:Src/main.c    ****   * @file    I2C/I2C_TwoBoards_ComDMA/Src/main.c
   4:Src/main.c    ****   * @author  MCD Application Team
   5:Src/main.c    ****   * @version V1.2.3
   6:Src/main.c    ****   * @date    09-October-2015 
   7:Src/main.c    ****   * @brief   This sample code shows how to use STM32F4xx I2C HAL API to transmit
   8:Src/main.c    ****   *          and receive a data buffer with a communication process based on
   9:Src/main.c    ****   *          DMA transfer. 
  10:Src/main.c    ****   *          The communication is done using 2 Boards.
  11:Src/main.c    ****   ******************************************************************************
  12:Src/main.c    ****   * @attention
  13:Src/main.c    ****   *
  14:Src/main.c    ****   * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
  15:Src/main.c    ****   *
  16:Src/main.c    ****   * Redistribution and use in source and binary forms, with or without modification,
  17:Src/main.c    ****   * are permitted provided that the following conditions are met:
  18:Src/main.c    ****   *   1. Redistributions of source code must retain the above copyright notice,
  19:Src/main.c    ****   *      this list of conditions and the following disclaimer.
  20:Src/main.c    ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  21:Src/main.c    ****   *      this list of conditions and the following disclaimer in the documentation
ARM GAS  /tmp/ccQbVy9H.s 			page 3


  22:Src/main.c    ****   *      and/or other materials provided with the distribution.
  23:Src/main.c    ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  24:Src/main.c    ****   *      may be used to endorse or promote products derived from this software
  25:Src/main.c    ****   *      without specific prior written permission.
  26:Src/main.c    ****   *
  27:Src/main.c    ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  28:Src/main.c    ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  29:Src/main.c    ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  30:Src/main.c    ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  31:Src/main.c    ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  32:Src/main.c    ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  33:Src/main.c    ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  34:Src/main.c    ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  35:Src/main.c    ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  36:Src/main.c    ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  37:Src/main.c    ****   *
  38:Src/main.c    ****   ******************************************************************************
  39:Src/main.c    ****   */
  40:Src/main.c    **** 
  41:Src/main.c    **** /* Includes ------------------------------------------------------------------*/
  42:Src/main.c    **** #include "main.h"
  43:Src/main.c    **** 
  44:Src/main.c    **** /** @addtogroup STM32F4xx_HAL_Examples
  45:Src/main.c    ****   * @{
  46:Src/main.c    ****   */
  47:Src/main.c    **** 
  48:Src/main.c    **** /** @addtogroup I2C_TwoBoards_ComDMA
  49:Src/main.c    ****   * @{
  50:Src/main.c    ****   */ 
  51:Src/main.c    **** 
  52:Src/main.c    **** /* Private typedef -----------------------------------------------------------*/
  53:Src/main.c    **** /* Private define ------------------------------------------------------------*/
  54:Src/main.c    **** /* Private macro -------------------------------------------------------------*/
  55:Src/main.c    **** #define I2C_ADDRESS        0x1D
  56:Src/main.c    **** 
  57:Src/main.c    **** /* Private variables ---------------------------------------------------------*/
  58:Src/main.c    **** /* I2C handler declaration */
  59:Src/main.c    **** extern I2C_HandleTypeDef I2cHandle;
  60:Src/main.c    **** 
  61:Src/main.c    **** /* Buffer used for transmission */
  62:Src/main.c    **** uint8_t aTxBuffer[] = {0, 0, 0, 0};
  63:Src/main.c    **** 
  64:Src/main.c    **** /* Buffer used for reception */
  65:Src/main.c    **** uint8_t aRxBuffer[RXBUFFERSIZE];
  66:Src/main.c    **** 
  67:Src/main.c    **** enum i2c_state {NONE, ACCEL_WRITE, ACCEL_READ, GYRO_WRITE, GYRO_READ};
  68:Src/main.c    **** 
  69:Src/main.c    **** enum i2c_state i2c = NONE;
  70:Src/main.c    **** 
  71:Src/main.c    **** uint8_t POWER_CTL = 0x2D;  //Power Control Register
  72:Src/main.c    **** uint8_t DATA_FORMAT = 0x31;
  73:Src/main.c    **** uint8_t DATAX0 = 0x32; //X-Axis Data 0
  74:Src/main.c    **** uint8_t DATAX1 = 0x33; //X-Axis Data 1
  75:Src/main.c    **** uint8_t DATAY0 = 0x34; //Y-Axis Data 0
  76:Src/main.c    **** uint8_t DATAY1 = 0x35; //Y-Axis Data 1
  77:Src/main.c    **** uint8_t DATAZ0 = 0x36; //Z-Axis Data 0
  78:Src/main.c    **** uint8_t DATAZ1 = 0x37; //Z-Axis Data 1
ARM GAS  /tmp/ccQbVy9H.s 			page 4


  79:Src/main.c    **** 
  80:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
  81:Src/main.c    **** static void SystemClock_Config(void);
  82:Src/main.c    **** static void Error_Handler(void);
  83:Src/main.c    **** uint8_t readFrom(uint8_t address, uint8_t num);
  84:Src/main.c    **** uint8_t writeTo(uint8_t address, uint8_t val);
  85:Src/main.c    **** 
  86:Src/main.c    **** /* Private functions ---------------------------------------------------------*/
  87:Src/main.c    **** 
  88:Src/main.c    **** /**
  89:Src/main.c    ****   * @brief  Main program
  90:Src/main.c    ****   * @param  None
  91:Src/main.c    ****   * @retval None
  92:Src/main.c    ****   */
  93:Src/main.c    **** int main(void)
  94:Src/main.c    **** {
 106              		.loc 1 94 0
 107              		.cfi_startproc
 108              		@ args = 0, pretend = 0, frame = 16
 109              		@ frame_needed = 1, uses_anonymous_args = 0
 110 0000 80B5     		push	{r7, lr}
 111              	.LCFI0:
 112              		.cfi_def_cfa_offset 8
 113              		.cfi_offset 7, -8
 114              		.cfi_offset 14, -4
 115 0002 84B0     		sub	sp, sp, #16
 116              	.LCFI1:
 117              		.cfi_def_cfa_offset 24
 118 0004 00AF     		add	r7, sp, #0
 119              	.LCFI2:
 120              		.cfi_def_cfa_register 7
  95:Src/main.c    ****   /* STM32F4xx HAL library initialization:
  96:Src/main.c    ****        - Configure the Flash prefetch, instruction and Data caches
  97:Src/main.c    ****        - Configure the Systick to generate an interrupt each 1 msec
  98:Src/main.c    ****        - Set NVIC Group Priority to 4
  99:Src/main.c    ****        - Global MSP (MCU Support Package) initialization
 100:Src/main.c    ****      */
 101:Src/main.c    ****   HAL_Init();
 121              		.loc 1 101 0
 122 0006 FFF7FEFF 		bl	HAL_Init
 102:Src/main.c    **** 
 103:Src/main.c    ****   /* Configure LED3 and LED4 */
 104:Src/main.c    ****   BSP_LED_Init(LED3);
 123              		.loc 1 104 0
 124 000a 0020     		movs	r0, #0
 125 000c FFF7FEFF 		bl	BSP_LED_Init
 105:Src/main.c    ****   BSP_LED_Init(LED4);
 126              		.loc 1 105 0
 127 0010 0120     		movs	r0, #1
 128 0012 FFF7FEFF 		bl	BSP_LED_Init
 106:Src/main.c    ****   
 107:Src/main.c    ****   /* Configure the system clock to 168 MHz */
 108:Src/main.c    ****   SystemClock_Config();
 129              		.loc 1 108 0
 130 0016 FFF7FEFF 		bl	SystemClock_Config
 109:Src/main.c    **** 
 110:Src/main.c    ****   /*##-1- Configure the I2C peripheral #######################################*/
ARM GAS  /tmp/ccQbVy9H.s 			page 5


 111:Src/main.c    ****   I2cHandle.Instance             = I2Cx;
 131              		.loc 1 111 0
 132 001a 414B     		ldr	r3, .L6
 133 001c 414A     		ldr	r2, .L6+4
 134 001e 1A60     		str	r2, [r3]
 112:Src/main.c    **** 
 113:Src/main.c    ****   I2cHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 135              		.loc 1 113 0
 136 0020 3F4B     		ldr	r3, .L6
 137 0022 4FF48042 		mov	r2, #16384
 138 0026 1A61     		str	r2, [r3, #16]
 114:Src/main.c    ****   I2cHandle.Init.ClockSpeed      = 400000;
 139              		.loc 1 114 0
 140 0028 3D4B     		ldr	r3, .L6
 141 002a 3F4A     		ldr	r2, .L6+8
 142 002c 5A60     		str	r2, [r3, #4]
 115:Src/main.c    ****   I2cHandle.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 143              		.loc 1 115 0
 144 002e 3C4B     		ldr	r3, .L6
 145 0030 0022     		movs	r2, #0
 146 0032 5A61     		str	r2, [r3, #20]
 116:Src/main.c    ****   I2cHandle.Init.DutyCycle       = I2C_DUTYCYCLE_2;
 147              		.loc 1 116 0
 148 0034 3A4B     		ldr	r3, .L6
 149 0036 0022     		movs	r2, #0
 150 0038 9A60     		str	r2, [r3, #8]
 117:Src/main.c    ****   I2cHandle.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 151              		.loc 1 117 0
 152 003a 394B     		ldr	r3, .L6
 153 003c 0022     		movs	r2, #0
 154 003e DA61     		str	r2, [r3, #28]
 118:Src/main.c    ****   I2cHandle.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
 155              		.loc 1 118 0
 156 0040 374B     		ldr	r3, .L6
 157 0042 0022     		movs	r2, #0
 158 0044 1A62     		str	r2, [r3, #32]
 119:Src/main.c    ****   I2cHandle.Init.OwnAddress1     = 0x10;
 159              		.loc 1 119 0
 160 0046 364B     		ldr	r3, .L6
 161 0048 1022     		movs	r2, #16
 162 004a DA60     		str	r2, [r3, #12]
 120:Src/main.c    ****   I2cHandle.Init.OwnAddress2     = 0x11;
 163              		.loc 1 120 0
 164 004c 344B     		ldr	r3, .L6
 165 004e 1122     		movs	r2, #17
 166 0050 9A61     		str	r2, [r3, #24]
 121:Src/main.c    ****   
 122:Src/main.c    ****   if(HAL_I2C_Init(&I2cHandle) != HAL_OK)
 167              		.loc 1 122 0
 168 0052 3348     		ldr	r0, .L6
 169 0054 FFF7FEFF 		bl	HAL_I2C_Init
 170 0058 0346     		mov	r3, r0
 171 005a 002B     		cmp	r3, #0
 172 005c 01D0     		beq	.L2
 123:Src/main.c    ****   {
 124:Src/main.c    ****     /* Initialization Error */
 125:Src/main.c    ****     Error_Handler();
ARM GAS  /tmp/ccQbVy9H.s 			page 6


 173              		.loc 1 125 0
 174 005e FFF7FEFF 		bl	Error_Handler
 175              	.L2:
 126:Src/main.c    ****   }
 127:Src/main.c    **** 
 128:Src/main.c    **** /*  uint8_t i = 0;
 129:Src/main.c    ****   for(i = 0; i<255; i++)
 130:Src/main.c    ****   {
 131:Src/main.c    ****     if(HAL_I2C_IsDeviceReady(&I2cHandle, I2C_ADDRESS << 1, 1, 100) == HAL_OK) {
 132:Src/main.c    ****   	  printf("Ready: 0x%02x\n", i);
 133:Src/main.c    ****     }
 134:Src/main.c    ****     else {
 135:Src/main.c    ****       printf("Not ready: 0x%02x\n", i);
 136:Src/main.c    ****     }
 137:Src/main.c    ****     HAL_Delay(100);
 138:Src/main.c    ****   }*/
 139:Src/main.c    **** 
 140:Src/main.c    ****   // +/- 2G range -  00;
 141:Src/main.c    ****   // +/- 4G range -  01;
 142:Src/main.c    ****   // +/- 8G range -  02;
 143:Src/main.c    ****   // +/- 16G range - 03;
 144:Src/main.c    ****   writeTo(DATA_FORMAT, 0x00);
 176              		.loc 1 144 0
 177 0062 324B     		ldr	r3, .L6+12
 178 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 179 0066 1846     		mov	r0, r3
 180 0068 0021     		movs	r1, #0
 181 006a FFF7FEFF 		bl	writeTo
 145:Src/main.c    ****   //Put the ADXL345 into Measurement Mode by writing 0x08 to the POWER_CTL register.
 146:Src/main.c    ****   writeTo(POWER_CTL, 0x08);
 182              		.loc 1 146 0
 183 006e 304B     		ldr	r3, .L6+16
 184 0070 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 185 0072 1846     		mov	r0, r3
 186 0074 0821     		movs	r1, #8
 187 0076 FFF7FEFF 		bl	writeTo
 147:Src/main.c    **** 
 148:Src/main.c    **** 
 149:Src/main.c    ****   /* Infinite loop */
 150:Src/main.c    ****   uint32_t TimeStart = HAL_GetTick();
 188              		.loc 1 150 0
 189 007a FFF7FEFF 		bl	HAL_GetTick
 190 007e F860     		str	r0, [r7, #12]
 151:Src/main.c    ****   uint32_t LoopCounter = 0;
 191              		.loc 1 151 0
 192 0080 0023     		movs	r3, #0
 193 0082 BB60     		str	r3, [r7, #8]
 194              	.L5:
 195              	.LBB2:
 152:Src/main.c    ****   while (1)
 153:Src/main.c    ****   {
 154:Src/main.c    **** 	HAL_Delay(2);
 196              		.loc 1 154 0
 197 0084 0220     		movs	r0, #2
 198 0086 FFF7FEFF 		bl	HAL_Delay
 155:Src/main.c    **** 
 156:Src/main.c    **** 	//read the acceleration data from the ADXL345
ARM GAS  /tmp/ccQbVy9H.s 			page 7


 157:Src/main.c    **** 	if (readFrom( DATAX0, 6) != 6) {
 199              		.loc 1 157 0
 200 008a 2A4B     		ldr	r3, .L6+20
 201 008c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 202 008e 1846     		mov	r0, r3
 203 0090 0621     		movs	r1, #6
 204 0092 FFF7FEFF 		bl	readFrom
 205 0096 0346     		mov	r3, r0
 206 0098 062B     		cmp	r3, #6
 207 009a 02D0     		beq	.L3
 158:Src/main.c    **** 	  printf("Read error\n");
 208              		.loc 1 158 0
 209 009c 2648     		ldr	r0, .L6+24
 210 009e FFF7FEFF 		bl	puts
 211              	.L3:
 159:Src/main.c    **** 	}
 160:Src/main.c    **** 
 161:Src/main.c    **** 	// each axis reading comes in 10 bit resolution, ie 2 bytes.  Least Significat Byte first!!
 162:Src/main.c    **** 	// thus we are converting both bytes in to one int
 163:Src/main.c    **** 	uint16_t x = (((uint16_t)aRxBuffer[1]) << 8) | aRxBuffer[0];
 212              		.loc 1 163 0
 213 00a2 264B     		ldr	r3, .L6+28
 214 00a4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 215 00a6 1B02     		lsls	r3, r3, #8
 216 00a8 9AB2     		uxth	r2, r3
 217 00aa 244B     		ldr	r3, .L6+28
 218 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 219 00ae 1343     		orrs	r3, r3, r2
 220 00b0 9BB2     		uxth	r3, r3
 221 00b2 FB80     		strh	r3, [r7, #6]	@ movhi
 164:Src/main.c    **** 	uint16_t y = (((uint16_t)aRxBuffer[3]) << 8) | aRxBuffer[2];
 222              		.loc 1 164 0
 223 00b4 214B     		ldr	r3, .L6+28
 224 00b6 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 225 00b8 1B02     		lsls	r3, r3, #8
 226 00ba 9AB2     		uxth	r2, r3
 227 00bc 1F4B     		ldr	r3, .L6+28
 228 00be 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 229 00c0 1343     		orrs	r3, r3, r2
 230 00c2 9BB2     		uxth	r3, r3
 231 00c4 BB80     		strh	r3, [r7, #4]	@ movhi
 165:Src/main.c    **** 	uint16_t z = (((uint16_t)aRxBuffer[5]) << 8) | aRxBuffer[4];
 232              		.loc 1 165 0
 233 00c6 1D4B     		ldr	r3, .L6+28
 234 00c8 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 235 00ca 1B02     		lsls	r3, r3, #8
 236 00cc 9AB2     		uxth	r2, r3
 237 00ce 1B4B     		ldr	r3, .L6+28
 238 00d0 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 239 00d2 1343     		orrs	r3, r3, r2
 240 00d4 9BB2     		uxth	r3, r3
 241 00d6 7B80     		strh	r3, [r7, #2]	@ movhi
 166:Src/main.c    **** 
 167:Src/main.c    **** 	if (HAL_GetTick() - TimeStart > 1000) {
 242              		.loc 1 167 0
 243 00d8 FFF7FEFF 		bl	HAL_GetTick
 244 00dc 0246     		mov	r2, r0
ARM GAS  /tmp/ccQbVy9H.s 			page 8


 245 00de FB68     		ldr	r3, [r7, #12]
 246 00e0 D31A     		subs	r3, r2, r3
 247 00e2 B3F57A7F 		cmp	r3, #1000
 248 00e6 17D9     		bls	.L4
 168:Src/main.c    **** 	  printf("x: %d", x);
 249              		.loc 1 168 0
 250 00e8 FB88     		ldrh	r3, [r7, #6]
 251 00ea 1548     		ldr	r0, .L6+32
 252 00ec 1946     		mov	r1, r3
 253 00ee FFF7FEFF 		bl	printf
 169:Src/main.c    **** 	  printf(" y: %d", y);
 254              		.loc 1 169 0
 255 00f2 BB88     		ldrh	r3, [r7, #4]
 256 00f4 1348     		ldr	r0, .L6+36
 257 00f6 1946     		mov	r1, r3
 258 00f8 FFF7FEFF 		bl	printf
 170:Src/main.c    **** 	  printf(" z: %d", z);
 259              		.loc 1 170 0
 260 00fc 7B88     		ldrh	r3, [r7, #2]
 261 00fe 1248     		ldr	r0, .L6+40
 262 0100 1946     		mov	r1, r3
 263 0102 FFF7FEFF 		bl	printf
 171:Src/main.c    **** 	  printf(" loop per second: %d\n", LoopCounter);
 264              		.loc 1 171 0
 265 0106 1148     		ldr	r0, .L6+44
 266 0108 B968     		ldr	r1, [r7, #8]
 267 010a FFF7FEFF 		bl	printf
 172:Src/main.c    **** 	  LoopCounter = 0;
 268              		.loc 1 172 0
 269 010e 0023     		movs	r3, #0
 270 0110 BB60     		str	r3, [r7, #8]
 173:Src/main.c    **** 	  TimeStart = HAL_GetTick();
 271              		.loc 1 173 0
 272 0112 FFF7FEFF 		bl	HAL_GetTick
 273 0116 F860     		str	r0, [r7, #12]
 274              	.L4:
 174:Src/main.c    **** 	}
 175:Src/main.c    **** 
 176:Src/main.c    **** 	LoopCounter++;
 275              		.loc 1 176 0
 276 0118 BB68     		ldr	r3, [r7, #8]
 277 011a 0133     		adds	r3, r3, #1
 278 011c BB60     		str	r3, [r7, #8]
 279              	.LBE2:
 177:Src/main.c    ****   }
 280              		.loc 1 177 0
 281 011e B1E7     		b	.L5
 282              	.L7:
 283              		.align	2
 284              	.L6:
 285 0120 00000000 		.word	I2cHandle
 286 0124 005C0040 		.word	1073765376
 287 0128 801A0600 		.word	400000
 288 012c 00000000 		.word	DATA_FORMAT
 289 0130 00000000 		.word	POWER_CTL
 290 0134 00000000 		.word	DATAX0
 291 0138 00000000 		.word	.LC0
ARM GAS  /tmp/ccQbVy9H.s 			page 9


 292 013c 00000000 		.word	aRxBuffer
 293 0140 0C000000 		.word	.LC1
 294 0144 14000000 		.word	.LC2
 295 0148 1C000000 		.word	.LC3
 296 014c 24000000 		.word	.LC4
 297              		.cfi_endproc
 298              	.LFE125:
 300              		.section	.text.writeTo,"ax",%progbits
 301              		.align	2
 302              		.global	writeTo
 303              		.thumb
 304              		.thumb_func
 306              	writeTo:
 307              	.LFB126:
 178:Src/main.c    **** }
 179:Src/main.c    **** 
 180:Src/main.c    **** uint8_t writeTo(uint8_t address, uint8_t val) {
 308              		.loc 1 180 0
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 8
 311              		@ frame_needed = 1, uses_anonymous_args = 0
 312 0000 80B5     		push	{r7, lr}
 313              	.LCFI3:
 314              		.cfi_def_cfa_offset 8
 315              		.cfi_offset 7, -8
 316              		.cfi_offset 14, -4
 317 0002 84B0     		sub	sp, sp, #16
 318              	.LCFI4:
 319              		.cfi_def_cfa_offset 24
 320 0004 02AF     		add	r7, sp, #8
 321              	.LCFI5:
 322              		.cfi_def_cfa 7, 16
 323 0006 0246     		mov	r2, r0
 324 0008 0B46     		mov	r3, r1
 325 000a FA71     		strb	r2, [r7, #7]
 326 000c BB71     		strb	r3, [r7, #6]
 181:Src/main.c    ****   // register address
 182:Src/main.c    ****   aTxBuffer[0] = address;
 327              		.loc 1 182 0
 328 000e 134B     		ldr	r3, .L12
 329 0010 FA79     		ldrb	r2, [r7, #7]
 330 0012 1A70     		strb	r2, [r3]
 183:Src/main.c    **** 
 184:Src/main.c    ****   if (HAL_I2C_Master_Transmit(&I2cHandle, I2C_ADDRESS << 1, (uint8_t*)aTxBuffer, 1, 1000) != HAL_OK
 331              		.loc 1 184 0
 332 0014 4FF47A73 		mov	r3, #1000
 333 0018 0093     		str	r3, [sp]
 334 001a 1148     		ldr	r0, .L12+4
 335 001c 3A21     		movs	r1, #58
 336 001e 0F4A     		ldr	r2, .L12
 337 0020 0123     		movs	r3, #1
 338 0022 FFF7FEFF 		bl	HAL_I2C_Master_Transmit
 339 0026 0346     		mov	r3, r0
 340 0028 002B     		cmp	r3, #0
 341 002a 01D0     		beq	.L9
 185:Src/main.c    **** 	return -1;
 342              		.loc 1 185 0
ARM GAS  /tmp/ccQbVy9H.s 			page 10


 343 002c FF23     		movs	r3, #255
 344 002e 11E0     		b	.L10
 345              	.L9:
 186:Src/main.c    ****   }
 187:Src/main.c    **** 
 188:Src/main.c    ****   // register value
 189:Src/main.c    ****   aTxBuffer[0] = val;
 346              		.loc 1 189 0
 347 0030 0A4B     		ldr	r3, .L12
 348 0032 BA79     		ldrb	r2, [r7, #6]
 349 0034 1A70     		strb	r2, [r3]
 190:Src/main.c    **** 
 191:Src/main.c    ****   if (HAL_I2C_Master_Transmit(&I2cHandle, I2C_ADDRESS << 1, (uint8_t*)aTxBuffer, 1, 1000) != HAL_OK
 350              		.loc 1 191 0
 351 0036 4FF47A73 		mov	r3, #1000
 352 003a 0093     		str	r3, [sp]
 353 003c 0848     		ldr	r0, .L12+4
 354 003e 3A21     		movs	r1, #58
 355 0040 064A     		ldr	r2, .L12
 356 0042 0123     		movs	r3, #1
 357 0044 FFF7FEFF 		bl	HAL_I2C_Master_Transmit
 358 0048 0346     		mov	r3, r0
 359 004a 002B     		cmp	r3, #0
 360 004c 01D0     		beq	.L11
 192:Src/main.c    **** 	return -1;
 361              		.loc 1 192 0
 362 004e FF23     		movs	r3, #255
 363 0050 00E0     		b	.L10
 364              	.L11:
 193:Src/main.c    ****   }
 194:Src/main.c    **** 
 195:Src/main.c    ****   return 1;
 365              		.loc 1 195 0
 366 0052 0123     		movs	r3, #1
 367              	.L10:
 196:Src/main.c    **** }
 368              		.loc 1 196 0
 369 0054 1846     		mov	r0, r3
 370 0056 0837     		adds	r7, r7, #8
 371 0058 BD46     		mov	sp, r7
 372              		@ sp needed
 373 005a 80BD     		pop	{r7, pc}
 374              	.L13:
 375              		.align	2
 376              	.L12:
 377 005c 00000000 		.word	aTxBuffer
 378 0060 00000000 		.word	I2cHandle
 379              		.cfi_endproc
 380              	.LFE126:
 382              		.section	.text.readFrom,"ax",%progbits
 383              		.align	2
 384              		.global	readFrom
 385              		.thumb
 386              		.thumb_func
 388              	readFrom:
 389              	.LFB127:
 197:Src/main.c    **** 
ARM GAS  /tmp/ccQbVy9H.s 			page 11


 198:Src/main.c    **** uint8_t readFrom(uint8_t address, uint8_t num) {
 390              		.loc 1 198 0
 391              		.cfi_startproc
 392              		@ args = 0, pretend = 0, frame = 8
 393              		@ frame_needed = 1, uses_anonymous_args = 0
 394 0000 80B5     		push	{r7, lr}
 395              	.LCFI6:
 396              		.cfi_def_cfa_offset 8
 397              		.cfi_offset 7, -8
 398              		.cfi_offset 14, -4
 399 0002 84B0     		sub	sp, sp, #16
 400              	.LCFI7:
 401              		.cfi_def_cfa_offset 24
 402 0004 02AF     		add	r7, sp, #8
 403              	.LCFI8:
 404              		.cfi_def_cfa 7, 16
 405 0006 0246     		mov	r2, r0
 406 0008 0B46     		mov	r3, r1
 407 000a FA71     		strb	r2, [r7, #7]
 408 000c BB71     		strb	r3, [r7, #6]
 199:Src/main.c    ****   // address to read from
 200:Src/main.c    ****   aTxBuffer[0] = address;
 409              		.loc 1 200 0
 410 000e 124B     		ldr	r3, .L18
 411 0010 FA79     		ldrb	r2, [r7, #7]
 412 0012 1A70     		strb	r2, [r3]
 201:Src/main.c    **** 
 202:Src/main.c    ****   if (HAL_I2C_Master_Transmit(&I2cHandle, I2C_ADDRESS << 1, (uint8_t*)aTxBuffer, 1, 1000) != HAL_OK
 413              		.loc 1 202 0
 414 0014 4FF47A73 		mov	r3, #1000
 415 0018 0093     		str	r3, [sp]
 416 001a 1048     		ldr	r0, .L18+4
 417 001c 3A21     		movs	r1, #58
 418 001e 0E4A     		ldr	r2, .L18
 419 0020 0123     		movs	r3, #1
 420 0022 FFF7FEFF 		bl	HAL_I2C_Master_Transmit
 421 0026 0346     		mov	r3, r0
 422 0028 002B     		cmp	r3, #0
 423 002a 01D0     		beq	.L15
 203:Src/main.c    ****     return -1;
 424              		.loc 1 203 0
 425 002c FF23     		movs	r3, #255
 426 002e 0FE0     		b	.L16
 427              	.L15:
 204:Src/main.c    ****   }
 205:Src/main.c    ****   if (HAL_I2C_Master_Receive(&I2cHandle, I2C_ADDRESS << 1, (uint8_t*)aRxBuffer, num, 1000) != HAL_O
 428              		.loc 1 205 0
 429 0030 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 430 0032 9BB2     		uxth	r3, r3
 431 0034 4FF47A72 		mov	r2, #1000
 432 0038 0092     		str	r2, [sp]
 433 003a 0848     		ldr	r0, .L18+4
 434 003c 3A21     		movs	r1, #58
 435 003e 084A     		ldr	r2, .L18+8
 436 0040 FFF7FEFF 		bl	HAL_I2C_Master_Receive
 437 0044 0346     		mov	r3, r0
 438 0046 002B     		cmp	r3, #0
ARM GAS  /tmp/ccQbVy9H.s 			page 12


 439 0048 01D0     		beq	.L17
 206:Src/main.c    **** 	return -1;
 440              		.loc 1 206 0
 441 004a FF23     		movs	r3, #255
 442 004c 00E0     		b	.L16
 443              	.L17:
 207:Src/main.c    ****   }
 208:Src/main.c    ****   return num;
 444              		.loc 1 208 0
 445 004e BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 446              	.L16:
 209:Src/main.c    **** }
 447              		.loc 1 209 0
 448 0050 1846     		mov	r0, r3
 449 0052 0837     		adds	r7, r7, #8
 450 0054 BD46     		mov	sp, r7
 451              		@ sp needed
 452 0056 80BD     		pop	{r7, pc}
 453              	.L19:
 454              		.align	2
 455              	.L18:
 456 0058 00000000 		.word	aTxBuffer
 457 005c 00000000 		.word	I2cHandle
 458 0060 00000000 		.word	aRxBuffer
 459              		.cfi_endproc
 460              	.LFE127:
 462              		.section	.text.Error_Handler,"ax",%progbits
 463              		.align	2
 464              		.thumb
 465              		.thumb_func
 467              	Error_Handler:
 468              	.LFB128:
 210:Src/main.c    **** 
 211:Src/main.c    **** /**
 212:Src/main.c    ****   * @brief  This function is executed in case of error occurrence.
 213:Src/main.c    ****   * @param  None
 214:Src/main.c    ****   * @retval None
 215:Src/main.c    ****   */
 216:Src/main.c    **** static void Error_Handler(void)
 217:Src/main.c    **** {
 469              		.loc 1 217 0
 470              		.cfi_startproc
 471              		@ args = 0, pretend = 0, frame = 0
 472              		@ frame_needed = 1, uses_anonymous_args = 0
 473 0000 80B5     		push	{r7, lr}
 474              	.LCFI9:
 475              		.cfi_def_cfa_offset 8
 476              		.cfi_offset 7, -8
 477              		.cfi_offset 14, -4
 478 0002 00AF     		add	r7, sp, #0
 479              	.LCFI10:
 480              		.cfi_def_cfa_register 7
 218:Src/main.c    ****   /* Turn LED4 on */
 219:Src/main.c    ****   BSP_LED_On(LED4);
 481              		.loc 1 219 0
 482 0004 0120     		movs	r0, #1
 483 0006 FFF7FEFF 		bl	BSP_LED_On
ARM GAS  /tmp/ccQbVy9H.s 			page 13


 484              	.L21:
 220:Src/main.c    ****   while(1)
 221:Src/main.c    ****   {
 222:Src/main.c    ****   }
 485              		.loc 1 222 0 discriminator 1
 486 000a FEE7     		b	.L21
 487              		.cfi_endproc
 488              	.LFE128:
 490              		.section	.text.SystemClock_Config,"ax",%progbits
 491              		.align	2
 492              		.thumb
 493              		.thumb_func
 495              	SystemClock_Config:
 496              	.LFB129:
 223:Src/main.c    **** }
 224:Src/main.c    **** 
 225:Src/main.c    **** /**
 226:Src/main.c    ****   * @brief  System Clock Configuration
 227:Src/main.c    ****   *         The system Clock is configured as follow : 
 228:Src/main.c    ****   *            System Clock source            = PLL (HSE)
 229:Src/main.c    ****   *            SYSCLK(Hz)                     = 180000000
 230:Src/main.c    ****   *            HCLK(Hz)                       = 180000000
 231:Src/main.c    ****   *            AHB Prescaler                  = 1
 232:Src/main.c    ****   *            APB1 Prescaler                 = 4
 233:Src/main.c    ****   *            APB2 Prescaler                 = 2
 234:Src/main.c    ****   *            HSE Frequency(Hz)              = 8000000
 235:Src/main.c    ****   *            PLL_M                          = 8
 236:Src/main.c    ****   *            PLL_N                          = 360
 237:Src/main.c    ****   *            PLL_P                          = 2
 238:Src/main.c    ****   *            PLL_Q                          = 7
 239:Src/main.c    ****   *            VDD(V)                         = 3.3
 240:Src/main.c    ****   *            Main regulator output voltage  = Scale1 mode
 241:Src/main.c    ****   *            Flash Latency(WS)              = 5
 242:Src/main.c    ****   * @param  None
 243:Src/main.c    ****   * @retval None
 244:Src/main.c    ****   */
 245:Src/main.c    **** static void SystemClock_Config(void)
 246:Src/main.c    **** {
 497              		.loc 1 246 0
 498              		.cfi_startproc
 499              		@ args = 0, pretend = 0, frame = 80
 500              		@ frame_needed = 1, uses_anonymous_args = 0
 501 0000 80B5     		push	{r7, lr}
 502              	.LCFI11:
 503              		.cfi_def_cfa_offset 8
 504              		.cfi_offset 7, -8
 505              		.cfi_offset 14, -4
 506 0002 94B0     		sub	sp, sp, #80
 507              	.LCFI12:
 508              		.cfi_def_cfa_offset 88
 509 0004 00AF     		add	r7, sp, #0
 510              	.LCFI13:
 511              		.cfi_def_cfa_register 7
 512              	.LBB3:
 247:Src/main.c    ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 248:Src/main.c    ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 249:Src/main.c    **** 
ARM GAS  /tmp/ccQbVy9H.s 			page 14


 250:Src/main.c    ****   /* Enable Power Control clock */
 251:Src/main.c    ****   __HAL_RCC_PWR_CLK_ENABLE();
 513              		.loc 1 251 0
 514 0006 234B     		ldr	r3, .L23
 515 0008 224A     		ldr	r2, .L23
 516 000a 126C     		ldr	r2, [r2, #64]
 517 000c 42F08052 		orr	r2, r2, #268435456
 518 0010 1A64     		str	r2, [r3, #64]
 519 0012 204B     		ldr	r3, .L23
 520 0014 1B6C     		ldr	r3, [r3, #64]
 521 0016 03F08053 		and	r3, r3, #268435456
 522 001a BB60     		str	r3, [r7, #8]
 523 001c BB68     		ldr	r3, [r7, #8]
 524              	.LBE3:
 525              	.LBB4:
 252:Src/main.c    ****   
 253:Src/main.c    ****   /* The voltage scaling allows optimizing the power consumption when the device is 
 254:Src/main.c    ****      clocked below the maximum system frequency, to update the voltage scaling value 
 255:Src/main.c    ****      regarding system frequency refer to product datasheet.  */
 256:Src/main.c    ****   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 526              		.loc 1 256 0
 527 001e 1E4B     		ldr	r3, .L23+4
 528 0020 1D4A     		ldr	r2, .L23+4
 529 0022 1268     		ldr	r2, [r2]
 530 0024 42F44042 		orr	r2, r2, #49152
 531 0028 1A60     		str	r2, [r3]
 532 002a 1B4B     		ldr	r3, .L23+4
 533 002c 1B68     		ldr	r3, [r3]
 534 002e 03F44043 		and	r3, r3, #49152
 535 0032 7B60     		str	r3, [r7, #4]
 536 0034 7B68     		ldr	r3, [r7, #4]
 537              	.LBE4:
 257:Src/main.c    ****   
 258:Src/main.c    ****   /* Enable HSE Oscillator and activate PLL with HSE as source */
 259:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 538              		.loc 1 259 0
 539 0036 0123     		movs	r3, #1
 540 0038 FB60     		str	r3, [r7, #12]
 260:Src/main.c    ****   RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 541              		.loc 1 260 0
 542 003a 0123     		movs	r3, #1
 543 003c 3B61     		str	r3, [r7, #16]
 261:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 544              		.loc 1 261 0
 545 003e 0223     		movs	r3, #2
 546 0040 7B62     		str	r3, [r7, #36]
 262:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 547              		.loc 1 262 0
 548 0042 4FF48003 		mov	r3, #4194304
 549 0046 BB62     		str	r3, [r7, #40]
 263:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLM = 8;
 550              		.loc 1 263 0
 551 0048 0823     		movs	r3, #8
 552 004a FB62     		str	r3, [r7, #44]
 264:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLN = 360;
 553              		.loc 1 264 0
 554 004c 4FF4B473 		mov	r3, #360
ARM GAS  /tmp/ccQbVy9H.s 			page 15


 555 0050 3B63     		str	r3, [r7, #48]
 265:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 556              		.loc 1 265 0
 557 0052 0223     		movs	r3, #2
 558 0054 7B63     		str	r3, [r7, #52]
 266:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLQ = 7;
 559              		.loc 1 266 0
 560 0056 0723     		movs	r3, #7
 561 0058 BB63     		str	r3, [r7, #56]
 267:Src/main.c    ****   HAL_RCC_OscConfig(&RCC_OscInitStruct);
 562              		.loc 1 267 0
 563 005a 07F10C03 		add	r3, r7, #12
 564 005e 1846     		mov	r0, r3
 565 0060 FFF7FEFF 		bl	HAL_RCC_OscConfig
 268:Src/main.c    **** 
 269:Src/main.c    ****   /* Activate the Over-Drive mode */
 270:Src/main.c    ****   HAL_PWREx_EnableOverDrive();
 566              		.loc 1 270 0
 567 0064 FFF7FEFF 		bl	HAL_PWREx_EnableOverDrive
 271:Src/main.c    **** 
 272:Src/main.c    ****   /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
 273:Src/main.c    ****      clocks dividers */
 274:Src/main.c    ****   RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | 
 568              		.loc 1 274 0
 569 0068 0F23     		movs	r3, #15
 570 006a FB63     		str	r3, [r7, #60]
 275:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 571              		.loc 1 275 0
 572 006c 0223     		movs	r3, #2
 573 006e 3B64     		str	r3, [r7, #64]
 276:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 574              		.loc 1 276 0
 575 0070 0023     		movs	r3, #0
 576 0072 7B64     		str	r3, [r7, #68]
 277:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
 577              		.loc 1 277 0
 578 0074 4FF4A053 		mov	r3, #5120
 579 0078 BB64     		str	r3, [r7, #72]
 278:Src/main.c    ****   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
 580              		.loc 1 278 0
 581 007a 4FF48053 		mov	r3, #4096
 582 007e FB64     		str	r3, [r7, #76]
 279:Src/main.c    ****   HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 583              		.loc 1 279 0
 584 0080 07F13C03 		add	r3, r7, #60
 585 0084 1846     		mov	r0, r3
 586 0086 0521     		movs	r1, #5
 587 0088 FFF7FEFF 		bl	HAL_RCC_ClockConfig
 280:Src/main.c    **** }
 588              		.loc 1 280 0
 589 008c 5037     		adds	r7, r7, #80
 590 008e BD46     		mov	sp, r7
 591              		@ sp needed
 592 0090 80BD     		pop	{r7, pc}
 593              	.L24:
 594 0092 00BF     		.align	2
 595              	.L23:
ARM GAS  /tmp/ccQbVy9H.s 			page 16


 596 0094 00380240 		.word	1073887232
 597 0098 00700040 		.word	1073770496
 598              		.cfi_endproc
 599              	.LFE129:
 601              		.section	.text.HAL_I2C_MasterTxCpltCallback,"ax",%progbits
 602              		.align	2
 603              		.global	HAL_I2C_MasterTxCpltCallback
 604              		.thumb
 605              		.thumb_func
 607              	HAL_I2C_MasterTxCpltCallback:
 608              	.LFB130:
 281:Src/main.c    **** 
 282:Src/main.c    **** 
 283:Src/main.c    **** /**
 284:Src/main.c    ****   * @brief  Tx Transfer completed callback.
 285:Src/main.c    ****   * @param  I2cHandle: I2C handle
 286:Src/main.c    ****   * @note   This example shows a simple way to report end of DMA Tx transfer, and 
 287:Src/main.c    ****   *         you can add your own implementation. 
 288:Src/main.c    ****   * @retval None
 289:Src/main.c    ****   */
 290:Src/main.c    **** 
 291:Src/main.c    **** void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *I2cHandle)
 292:Src/main.c    **** {
 609              		.loc 1 292 0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 8
 612              		@ frame_needed = 1, uses_anonymous_args = 0
 613 0000 80B5     		push	{r7, lr}
 614              	.LCFI14:
 615              		.cfi_def_cfa_offset 8
 616              		.cfi_offset 7, -8
 617              		.cfi_offset 14, -4
 618 0002 82B0     		sub	sp, sp, #8
 619              	.LCFI15:
 620              		.cfi_def_cfa_offset 16
 621 0004 00AF     		add	r7, sp, #0
 622              	.LCFI16:
 623              		.cfi_def_cfa_register 7
 624 0006 7860     		str	r0, [r7, #4]
 293:Src/main.c    ****   /* Toggle LED3: Transfer in transmission process is correct */
 294:Src/main.c    ****   BSP_LED_Toggle(LED3);
 625              		.loc 1 294 0
 626 0008 0020     		movs	r0, #0
 627 000a FFF7FEFF 		bl	BSP_LED_Toggle
 295:Src/main.c    **** }
 628              		.loc 1 295 0
 629 000e 0837     		adds	r7, r7, #8
 630 0010 BD46     		mov	sp, r7
 631              		@ sp needed
 632 0012 80BD     		pop	{r7, pc}
 633              		.cfi_endproc
 634              	.LFE130:
 636              		.section	.text.HAL_I2C_MasterRxCpltCallback,"ax",%progbits
 637              		.align	2
 638              		.global	HAL_I2C_MasterRxCpltCallback
 639              		.thumb
 640              		.thumb_func
ARM GAS  /tmp/ccQbVy9H.s 			page 17


 642              	HAL_I2C_MasterRxCpltCallback:
 643              	.LFB131:
 296:Src/main.c    **** 
 297:Src/main.c    **** /**
 298:Src/main.c    ****   * @brief  Rx Transfer completed callback.
 299:Src/main.c    ****   * @param  I2cHandle: I2C handle
 300:Src/main.c    ****   * @note   This example shows a simple way to report end of DMA Rx transfer, and 
 301:Src/main.c    ****   *         you can add your own implementation.
 302:Src/main.c    ****   * @retval None
 303:Src/main.c    ****   */
 304:Src/main.c    **** 
 305:Src/main.c    **** void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *I2cHandle)
 306:Src/main.c    **** {
 644              		.loc 1 306 0
 645              		.cfi_startproc
 646              		@ args = 0, pretend = 0, frame = 8
 647              		@ frame_needed = 1, uses_anonymous_args = 0
 648 0000 80B5     		push	{r7, lr}
 649              	.LCFI17:
 650              		.cfi_def_cfa_offset 8
 651              		.cfi_offset 7, -8
 652              		.cfi_offset 14, -4
 653 0002 82B0     		sub	sp, sp, #8
 654              	.LCFI18:
 655              		.cfi_def_cfa_offset 16
 656 0004 00AF     		add	r7, sp, #0
 657              	.LCFI19:
 658              		.cfi_def_cfa_register 7
 659 0006 7860     		str	r0, [r7, #4]
 307:Src/main.c    ****   /* Toggle LED3: Transfer in reception process is correct */
 308:Src/main.c    ****   BSP_LED_Toggle(LED3);
 660              		.loc 1 308 0
 661 0008 0020     		movs	r0, #0
 662 000a FFF7FEFF 		bl	BSP_LED_Toggle
 309:Src/main.c    **** }
 663              		.loc 1 309 0
 664 000e 0837     		adds	r7, r7, #8
 665 0010 BD46     		mov	sp, r7
 666              		@ sp needed
 667 0012 80BD     		pop	{r7, pc}
 668              		.cfi_endproc
 669              	.LFE131:
 671              		.section	.text.HAL_I2C_ErrorCallback,"ax",%progbits
 672              		.align	2
 673              		.global	HAL_I2C_ErrorCallback
 674              		.thumb
 675              		.thumb_func
 677              	HAL_I2C_ErrorCallback:
 678              	.LFB132:
 310:Src/main.c    **** 
 311:Src/main.c    **** /**
 312:Src/main.c    ****   * @brief  I2C error callbacks.
 313:Src/main.c    ****   * @param  I2cHandle: I2C handle
 314:Src/main.c    ****   * @note   This example shows a simple way to report transfer error, and you can
 315:Src/main.c    ****   *         add your own implementation.
 316:Src/main.c    ****   * @retval None
 317:Src/main.c    ****   */
ARM GAS  /tmp/ccQbVy9H.s 			page 18


 318:Src/main.c    ****  void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *I2cHandle)
 319:Src/main.c    **** {
 679              		.loc 1 319 0
 680              		.cfi_startproc
 681              		@ args = 0, pretend = 0, frame = 8
 682              		@ frame_needed = 1, uses_anonymous_args = 0
 683 0000 80B5     		push	{r7, lr}
 684              	.LCFI20:
 685              		.cfi_def_cfa_offset 8
 686              		.cfi_offset 7, -8
 687              		.cfi_offset 14, -4
 688 0002 82B0     		sub	sp, sp, #8
 689              	.LCFI21:
 690              		.cfi_def_cfa_offset 16
 691 0004 00AF     		add	r7, sp, #0
 692              	.LCFI22:
 693              		.cfi_def_cfa_register 7
 694 0006 7860     		str	r0, [r7, #4]
 320:Src/main.c    ****   /* Turn LED4 on: Transfer error in reception/transmission process */
 321:Src/main.c    ****   BSP_LED_On(LED4);
 695              		.loc 1 321 0
 696 0008 0120     		movs	r0, #1
 697 000a FFF7FEFF 		bl	BSP_LED_On
 322:Src/main.c    **** }
 698              		.loc 1 322 0
 699 000e 0837     		adds	r7, r7, #8
 700 0010 BD46     		mov	sp, r7
 701              		@ sp needed
 702 0012 80BD     		pop	{r7, pc}
 703              		.cfi_endproc
 704              	.LFE132:
 706              		.text
 707              	.Letext0:
 708              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 709              		.file 3 "/usr/include/newlib/stdint.h"
 710              		.file 4 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f429xx.h"
 711              		.file 5 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 712              		.file 6 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_rcc_ex.h"
 713              		.file 7 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_rcc.h"
 714              		.file 8 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 715              		.file 9 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_i2c.h"
 716              		.file 10 "Drivers/BSP/STM32F429I-Discovery/stm32f429i_discovery.h"
 717              		.file 11 "Drivers/CMSIS/Include/core_cm4.h"
ARM GAS  /tmp/ccQbVy9H.s 			page 19


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccQbVy9H.s:24     .bss.aTxBuffer:0000000000000000 aTxBuffer
     /tmp/ccQbVy9H.s:21     .bss.aTxBuffer:0000000000000000 $d
                            *COM*:0000000000000003 aRxBuffer
     /tmp/ccQbVy9H.s:31     .bss.i2c:0000000000000000 i2c
     /tmp/ccQbVy9H.s:32     .bss.i2c:0000000000000000 $d
     /tmp/ccQbVy9H.s:37     .data.POWER_CTL:0000000000000000 POWER_CTL
     /tmp/ccQbVy9H.s:43     .data.DATA_FORMAT:0000000000000000 DATA_FORMAT
     /tmp/ccQbVy9H.s:49     .data.DATAX0:0000000000000000 DATAX0
     /tmp/ccQbVy9H.s:55     .data.DATAX1:0000000000000000 DATAX1
     /tmp/ccQbVy9H.s:61     .data.DATAY0:0000000000000000 DATAY0
     /tmp/ccQbVy9H.s:67     .data.DATAY1:0000000000000000 DATAY1
     /tmp/ccQbVy9H.s:73     .data.DATAZ0:0000000000000000 DATAZ0
     /tmp/ccQbVy9H.s:79     .data.DATAZ1:0000000000000000 DATAZ1
     /tmp/ccQbVy9H.s:82     .rodata:0000000000000000 $d
     /tmp/ccQbVy9H.s:98     .text.main:0000000000000000 $t
     /tmp/ccQbVy9H.s:103    .text.main:0000000000000000 main
     /tmp/ccQbVy9H.s:495    .text.SystemClock_Config:0000000000000000 SystemClock_Config
     /tmp/ccQbVy9H.s:467    .text.Error_Handler:0000000000000000 Error_Handler
     /tmp/ccQbVy9H.s:306    .text.writeTo:0000000000000000 writeTo
     /tmp/ccQbVy9H.s:388    .text.readFrom:0000000000000000 readFrom
     /tmp/ccQbVy9H.s:285    .text.main:0000000000000120 $d
     /tmp/ccQbVy9H.s:301    .text.writeTo:0000000000000000 $t
     /tmp/ccQbVy9H.s:377    .text.writeTo:000000000000005c $d
     /tmp/ccQbVy9H.s:383    .text.readFrom:0000000000000000 $t
     /tmp/ccQbVy9H.s:456    .text.readFrom:0000000000000058 $d
     /tmp/ccQbVy9H.s:463    .text.Error_Handler:0000000000000000 $t
     /tmp/ccQbVy9H.s:491    .text.SystemClock_Config:0000000000000000 $t
     /tmp/ccQbVy9H.s:596    .text.SystemClock_Config:0000000000000094 $d
     /tmp/ccQbVy9H.s:602    .text.HAL_I2C_MasterTxCpltCallback:0000000000000000 $t
     /tmp/ccQbVy9H.s:607    .text.HAL_I2C_MasterTxCpltCallback:0000000000000000 HAL_I2C_MasterTxCpltCallback
     /tmp/ccQbVy9H.s:637    .text.HAL_I2C_MasterRxCpltCallback:0000000000000000 $t
     /tmp/ccQbVy9H.s:642    .text.HAL_I2C_MasterRxCpltCallback:0000000000000000 HAL_I2C_MasterRxCpltCallback
     /tmp/ccQbVy9H.s:672    .text.HAL_I2C_ErrorCallback:0000000000000000 $t
     /tmp/ccQbVy9H.s:677    .text.HAL_I2C_ErrorCallback:0000000000000000 HAL_I2C_ErrorCallback
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_Init
BSP_LED_Init
HAL_I2C_Init
HAL_GetTick
HAL_Delay
puts
printf
I2cHandle
HAL_I2C_Master_Transmit
HAL_I2C_Master_Receive
BSP_LED_On
HAL_RCC_OscConfig
HAL_PWREx_EnableOverDrive
HAL_RCC_ClockConfig
BSP_LED_Toggle
